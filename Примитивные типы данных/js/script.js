//1 task

const someVar = 'JavaScript is fun!';

console.log(someVar.includes('fun'));

//2 task

let someValue = 0;

if (!someValue) {
    console.log("Переменная имеет falsy значение");
} else {
    console.log("Переменная имеет truthy значение");
}

// 3 task

const firstName = 'John';
const lastName = 'Doe';
const occupation = 'software developer';
const fullName = firstName.concat(' ' + lastName)
const greeting = `Hello, my name is ${fullName}. I am a ${occupation}`
console.log(greeting)

// 4 task

let someVar1;

let someVar2 = null;

let a = someVar1 === someVar2;
let b = someVar1 == someVar2;

console.log (a)
console.log (b)

/*
null задаётся переменной явно и означает, что она является объектом, но структура этого объекта ещё не определена. 
undefined присваивается переменной (переменная не декларирует объект), когда она была объявлена, но не было определено её начальное значение.
В первом случае мы сравниваем с учетом типа данных. Так как, null является объектом, заданным для начального значения для второй переменной, а первая переменная не имеет такого объекта, то срабатывает эффект сравнения пустого стакана с наполненным. 
Результат - стаканы не похожи, так как один полный, а другой пуст.
Во втором же случае, мы не сравниваем тип данных, а сравниваем значение, которого нет ни у одной, ни у второй переменной, так как первая не определена, а вторая - пустая.
В этом случае первый стакан пуст, а второй - наполнен водой. Но сравнение на прозрачность все равно проведено успешно, так как посмотреть сквозь них можно (абстрактно, не обращая внимания на преломление света и деформации изображения).
*/

// 5 task 

const v = 1;
const g = '1';

console.log (v + g);

/* 
В этом случае произошла конкатенация строк, которая "прибавила" строку g к значению переменной v.
Значение v в этом случае было приведено к формату string, так конкатенация предназначена для работы со строками, и все операнды должны быть приведены к строковому формату.
*/

console.log (1 + '1')

/*
При выводе без назначения переменных, эффект сохранится, так как операнды по прежнему имеют разный формат.
*/